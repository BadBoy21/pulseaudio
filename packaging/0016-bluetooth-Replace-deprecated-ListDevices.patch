From 35d8c4334864c5e675da101f6c18ba00e2c030ba Mon Sep 17 00:00:00 2001
From: Mikel Astiz <mikel.astiz@bmw-carit.de>
Date: Thu, 26 Jul 2012 12:36:32 +0200
Subject: [PATCH 16/48] bluetooth: Replace deprecated ListDevices()

The method ListDevices() in org.bluez.Adapter was deprecated in BlueZ
4.61, and is going to be removed in future releases. Instead, a property
was introduced for this purpose in BlueZ 4.7.
---
 src/modules/bluetooth/bluetooth-util.c |   99 ++++++++++++++++----------------
 1 files changed, 49 insertions(+), 50 deletions(-)

diff --git a/src/modules/bluetooth/bluetooth-util.c b/src/modules/bluetooth/bluetooth-util.c
index d3557ab..bb32ad2 100644
--- a/src/modules/bluetooth/bluetooth-util.c
+++ b/src/modules/bluetooth/bluetooth-util.c
@@ -76,6 +76,7 @@ struct pa_bluetooth_discovery {
 static void get_properties_reply(DBusPendingCall *pending, void *userdata);
 static pa_dbus_pending* send_and_add_to_pending(pa_bluetooth_discovery *y, DBusMessage *m, DBusPendingCallNotifyFunction func, void *call_data);
 static void found_adapter(pa_bluetooth_discovery *y, const char *path);
+static pa_bluetooth_device *found_device(pa_bluetooth_discovery *y, const char* path);
 
 pa_bt_audio_state_t pa_bt_audio_state_from_string(const char* value) {
     pa_assert(value);
@@ -250,6 +251,46 @@ static int parse_manager_property(pa_bluetooth_discovery *y, DBusMessageIter *i)
     return 0;
 }
 
+static int parse_adapter_property(pa_bluetooth_discovery *y, DBusMessageIter *i) {
+    const char *key;
+    DBusMessageIter variant_i;
+
+    pa_assert(y);
+
+    key = check_variant_property(i);
+    if (key == NULL)
+        return -1;
+
+    dbus_message_iter_recurse(i, &variant_i);
+
+    switch (dbus_message_iter_get_arg_type(&variant_i)) {
+
+        case DBUS_TYPE_ARRAY: {
+
+            DBusMessageIter ai;
+            dbus_message_iter_recurse(&variant_i, &ai);
+
+            if (dbus_message_iter_get_arg_type(&ai) == DBUS_TYPE_OBJECT_PATH &&
+                pa_streq(key, "Devices")) {
+
+                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
+                    const char *value;
+
+                    dbus_message_iter_get_basic(&ai, &value);
+
+                    found_device(y, value);
+
+                    dbus_message_iter_next(&ai);
+                }
+            }
+
+            break;
+        }
+    }
+
+    return 0;
+}
+
 static int parse_device_property(pa_bluetooth_discovery *y, pa_bluetooth_device *d, DBusMessageIter *i) {
     const char *key;
     DBusMessageIter variant_i;
@@ -471,7 +512,8 @@ static void get_properties_reply(DBusPendingCall *pending, void *userdata) {
     /* We don't use p->call_data here right-away since the device
      * might already be invalidated at this point */
 
-    if (dbus_message_has_interface(p->message, "org.bluez.Manager"))
+    if (dbus_message_has_interface(p->message, "org.bluez.Manager") ||
+        dbus_message_has_interface(p->message, "org.bluez.Adapter"))
         d = NULL;
     else
         d = pa_hashmap_get(y->devices, dbus_message_get_path(p->message));
@@ -516,6 +558,10 @@ static void get_properties_reply(DBusPendingCall *pending, void *userdata) {
                 if (parse_manager_property(y, &dict_i) < 0)
                     goto finish;
 
+            } else if (dbus_message_has_interface(p->message, "org.bluez.Adapter")) {
+                if (parse_adapter_property(y, &dict_i) < 0)
+                    goto finish;
+
             } else if (dbus_message_has_interface(p->message, "org.bluez.Device")) {
                 if (parse_device_property(y, d, &dict_i) < 0)
                     goto finish;
@@ -615,53 +661,6 @@ finish:
     pa_xfree(endpoint);
 }
 
-static void list_devices_reply(DBusPendingCall *pending, void *userdata) {
-    DBusError e;
-    DBusMessage *r;
-    char **paths = NULL;
-    int num = -1;
-    pa_dbus_pending *p;
-    pa_bluetooth_discovery *y;
-
-    pa_assert(pending);
-
-    dbus_error_init(&e);
-
-    pa_assert_se(p = userdata);
-    pa_assert_se(y = p->context_data);
-    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
-
-    if (dbus_message_is_error(r, DBUS_ERROR_SERVICE_UNKNOWN)) {
-        pa_log_debug("Bluetooth daemon is apparently not available.");
-        remove_all_devices(y);
-        goto finish;
-    }
-
-    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log("org.bluez.Adapter.ListDevices() failed: %s: %s", dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
-        goto finish;
-    }
-
-    if (!dbus_message_get_args(r, &e, DBUS_TYPE_ARRAY, DBUS_TYPE_OBJECT_PATH, &paths, &num, DBUS_TYPE_INVALID)) {
-        pa_log("org.bluez.Adapter.ListDevices returned an error: '%s'\n", e.message);
-        dbus_error_free(&e);
-    } else {
-        int i;
-
-        for (i = 0; i < num; ++i)
-            found_device(y, paths[i]);
-    }
-
-finish:
-    if (paths)
-        dbus_free_string_array(paths);
-
-    dbus_message_unref(r);
-
-    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
-    pa_dbus_pending_free(p);
-}
-
 static void register_endpoint(pa_bluetooth_discovery *y, const char *path, const char *endpoint, const char *uuid) {
     DBusMessage *m;
     DBusMessageIter i, d;
@@ -711,8 +710,8 @@ static void register_endpoint(pa_bluetooth_discovery *y, const char *path, const
 static void found_adapter(pa_bluetooth_discovery *y, const char *path) {
     DBusMessage *m;
 
-    pa_assert_se(m = dbus_message_new_method_call("org.bluez", path, "org.bluez.Adapter", "ListDevices"));
-    send_and_add_to_pending(y, m, list_devices_reply, NULL);
+    pa_assert_se(m = dbus_message_new_method_call("org.bluez", path, "org.bluez.Adapter", "GetProperties"));
+    send_and_add_to_pending(y, m, get_properties_reply, NULL);
 
     register_endpoint(y, path, HFP_AG_ENDPOINT, HFP_AG_UUID);
     register_endpoint(y, path, HFP_HS_ENDPOINT, HFP_HS_UUID);
-- 
1.7.7.6

