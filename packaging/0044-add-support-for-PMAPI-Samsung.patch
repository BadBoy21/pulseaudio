From 21860b76a202396abac640063f584229b624d45f Mon Sep 17 00:00:00 2001
From: Jaska Uimonen <jaska.uimonen@intel.com>
Date: Wed, 10 Oct 2012 14:08:57 +0300
Subject: [PATCH 44/48] add support for PMAPI - Samsung

---
 configure.ac                         |   18 +++++++++
 src/modules/module-suspend-on-idle.c |   70 ++++++++++++++++++++++++++++++++-
 2 files changed, 85 insertions(+), 3 deletions(-)

diff --git a/configure.ac b/configure.ac
index 5cff178..a3c11f4 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1255,6 +1255,22 @@ AS_IF([test "x$enable_adrian_aec" != "xno"],
 AM_CONDITIONAL([HAVE_ADRIAN_EC], [test "x$HAVE_ADRIAN_EC" = "x1"])
 
 
+AC_ARG_ENABLE(pmapi, AC_HELP_STRING([--enable-pmapi], [using Samsung power management api]),
+[
+ case "${enableval}" in
+         yes) HAVE_PMAPI=yes ;;
+         no)  HAVE_PMAPI=no ;;
+         *)   AC_MSG_ERROR(bad value ${enableval} for --enable-pmapi) ;;
+ esac
+ ],[HAVE_PMAPI=no])
+
+if test "x$HAVE_PMAPI" = "xyes"; then
+        PKG_CHECK_MODULES(PMAPI, [capi-system-power])
+        AC_SUBST(PMAPI_CFLAGS)
+        AC_SUBST(PMAPI_LIBS)
+fi
+AM_CONDITIONAL(HAVE_PMAPI, test "x$HAVE_PMAPI" = "xyes")
+
 
 ###################################
 #            Output               #
@@ -1409,6 +1425,7 @@ AS_IF([test "x$HAVE_ADRIAN_EC" = "x1"], ENABLE_ADRIAN_EC=yes, ENABLE_ADRIAN_EC=n
 AS_IF([test "x$HAVE_SPEEX" = "x1"], ENABLE_SPEEX=yes, ENABLE_SPEEX=no)
 AS_IF([test "x$HAVE_WEBRTC" = "x1"], ENABLE_WEBRTC=yes, ENABLE_WEBRTC=no)
 AS_IF([test "x$HAVE_DLOG" = "xyes"], ENABLE_DLOG=yes, ENABLE_DLOG=no)
+AS_IF([test "x$HAVE_PMAPI" = "xyes"], ENABLE_PMAPI=yes, ENABLE_PMAPI=no)
 AS_IF([test "x$HAVE_TDB" = "x1"], ENABLE_TDB=yes, ENABLE_TDB=no)
 AS_IF([test "x$HAVE_GDBM" = "x1"], ENABLE_GDBM=yes, ENABLE_GDBM=no)
 AS_IF([test "x$HAVE_SIMPLEDB" = "x1"], ENABLE_SIMPLEDB=yes, ENABLE_SIMPLEDB=no)
@@ -1463,6 +1480,7 @@ echo "
     Enable speex (resampler, AEC): ${ENABLE_SPEEX}
     Enable WebRTC echo canceller:  ${ENABLE_WEBRTC}
     Enable DLOG:                   ${ENABLE_DLOG}
+    Enable PMAPI:                  ${ENABLE_PMAPI}
     Database
       tdb:                         ${ENABLE_TDB}
       gdbm:                        ${ENABLE_GDBM}
diff --git a/src/modules/module-suspend-on-idle.c b/src/modules/module-suspend-on-idle.c
index 07d937c..58b56a5 100644
--- a/src/modules/module-suspend-on-idle.c
+++ b/src/modules/module-suspend-on-idle.c
@@ -34,6 +34,10 @@
 #include <pulsecore/modargs.h>
 #include <pulsecore/log.h>
 
+#ifdef HAVE_PMAPI
+#include <power.h>
+#endif
+
 #include "module-suspend-on-idle-symdef.h"
 
 PA_MODULE_AUTHOR("Lennart Poettering");
@@ -42,6 +46,13 @@ PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(TRUE);
 PA_MODULE_USAGE("timeout=<timeout>");
 
+#ifdef HAVE_PMAPI
+#define PM_TYPE_SINK   0x01
+#define PM_TYPE_SOURCE 0x02
+#define UPDATE_PM_LOCK(current,type)   (current |= type)
+#define UPDATE_PM_UNLOCK(current,type) (current &= ~type)
+#endif
+
 static const char* const valid_modargs[] = {
     "timeout",
     NULL,
@@ -70,6 +81,9 @@ struct userdata {
         *source_output_move_finish_slot,
         *sink_input_state_changed_slot,
         *source_output_state_changed_slot;
+#ifdef HAVE_PMAPI
+    uint32_t pm_state;
+#endif
 };
 
 struct device_info {
@@ -83,6 +97,10 @@ struct device_info {
 static void timeout_cb(pa_mainloop_api*a, pa_time_event* e, const struct timeval *t, void *userdata) {
     struct device_info *d = userdata;
 
+#ifdef HAVE_PMAPI
+    int ret = -1;
+#endif
+
     pa_assert(d);
 
     d->userdata->core->mainloop->time_restart(d->time_event, NULL);
@@ -91,12 +109,32 @@ static void timeout_cb(pa_mainloop_api*a, pa_time_event* e, const struct timeval
         pa_log_info("Sink %s idle for too long, suspending ...", d->sink->name);
         pa_sink_suspend(d->sink, TRUE, PA_SUSPEND_IDLE);
         pa_core_maybe_vacuum(d->userdata->core);
+#ifdef HAVE_PMAPI
+	UPDATE_PM_UNLOCK(d->userdata->pm_state, PM_TYPE_SINK);
+	if(!(d->userdata->pm_state)) {
+	    ret = power_unlock_state(POWER_STATE_SCREEN_OFF)
+		if(!ret)
+		    pa_log_info("sink pm_unlock_state success");
+		else
+		    pa_log_error("sink pm_unlock_state failed [%d]", ret);
+	}
+#endif
     }
 
     if (d->source && pa_source_check_suspend(d->source) <= 0 && !(d->source->suspend_cause & PA_SUSPEND_IDLE)) {
         pa_log_info("Source %s idle for too long, suspending ...", d->source->name);
         pa_source_suspend(d->source, TRUE, PA_SUSPEND_IDLE);
         pa_core_maybe_vacuum(d->userdata->core);
+#ifdef HAVE_PMAPI
+	UPDATE_PM_UNLOCK(d->userdata->pm_state, PM_TYPE_SOURCE);
+	if(!(d->userdata->pm_state)) {
+	    ret = power_unlock_state(POWER_STATE_SCREEN_OFF);
+	    if(!ret)
+		pa_log_info("source pm_unlock_state success");
+	    else
+		pa_log_error("source pm_unlock_state failed [%d]", ret);
+	}
+#endif
     }
 }
 
@@ -105,6 +143,10 @@ static void restart(struct device_info *d) {
     const char *s;
     uint32_t timeout;
 
+#ifdef HAVE_PMAPI
+    int ret = -1;
+#endif
+
     pa_assert(d);
     pa_assert(d->sink || d->source);
 
@@ -116,10 +158,28 @@ static void restart(struct device_info *d) {
 
     pa_core_rttime_restart(d->userdata->core, d->time_event, now + timeout * PA_USEC_PER_SEC);
 
-    if (d->sink)
-        pa_log_debug("Sink %s becomes idle, timeout in %u seconds.", d->sink->name, timeout);
-    if (d->source)
+    if (d->sink) {
+#ifdef HAVE_PMAPI
+	UPDATE_PM_LOCK(d->userdata->pm_state, PM_TYPE_SINK);
+	ret = power_lock_state(POWER_STATE_SCREEN_OFF, 0);
+	if(!ret)
+	    pa_log_info("sink pm_lock_state success");
+	else
+	    pa_log_error("sink pm_lock_state failed [%d]", ret);
+#endif
+	pa_log_debug("Sink %s becomes idle, timeout in %u seconds.", d->sink->name, timeout);
+    }
+    if (d->source) {
+#ifdef HAVE_PMAPI
+	UPDATE_PM_LOCK(d->userdata->pm_state, PM_TYPE_SOURCE);
+	ret = power_lock_state(POWER_STATE_SCREEN_OFF, 0);
+	if(!ret)
+	    pa_log_info("source pm_lock_state success");
+	else
+	    pa_log_error("source pm_lock_state failed [%d]", ret);
+#endif
         pa_log_debug("Source %s becomes idle, timeout in %u seconds.", d->source->name, timeout);
+    }
 }
 
 static void resume(struct device_info *d) {
@@ -439,6 +499,10 @@ int pa__init(pa_module*m) {
     u->timeout = timeout;
     u->device_infos = pa_hashmap_new(pa_idxset_trivial_hash_func, pa_idxset_trivial_compare_func);
 
+#ifdef HAVE_PMAPI
+    u->pm_state = 0x00;
+#endif
+
     for (sink = pa_idxset_first(m->core->sinks, &idx); sink; sink = pa_idxset_next(m->core->sinks, &idx))
         device_new_hook_cb(m->core, PA_OBJECT(sink), u);
 
-- 
1.7.7.6

